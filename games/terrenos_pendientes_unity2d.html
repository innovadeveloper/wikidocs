<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrenos con Pendientes Unity 2D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2E8B57 0%, #3CB371 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            color: white;
        }

        .header h1 {
            font-size: 2.8em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.3em;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .techniques-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .technique-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .technique-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: var(--accent-color);
        }

        .technique-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
        }

        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }

        .card-icon {
            font-size: 2.5em;
            margin-right: 15px;
        }

        .card-title {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--accent-color);
        }

        .difficulty {
            background: var(--difficulty-color);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            margin-left: auto;
            font-weight: bold;
        }

        .code-snippet {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }

        .visual-example {
            background: #f8f9fa;
            border: 2px dashed #6c757d;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            text-align: center;
            position: relative;
        }

        .canvas-demo {
            width: 100%;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 30%, #228B22 30%, #228B22 100%);
        }

        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }

        .pros, .cons {
            padding: 15px;
            border-radius: 8px;
        }

        .pros {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }

        .cons {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }

        .pros h5, .cons h5 {
            margin-bottom: 10px;
            font-weight: bold;
        }

        .pros h5::before {
            content: '‚úÖ ';
        }

        .cons h5::before {
            content: '‚ùå ';
        }

        .implementation-steps {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #2196f3;
        }

        .implementation-steps h4 {
            color: #1976d2;
            margin-bottom: 15px;
        }

        .step-list {
            list-style: none;
            counter-reset: step-counter;
        }

        .step-list li {
            counter-increment: step-counter;
            margin: 10px 0;
            padding-left: 40px;
            position: relative;
        }

        .step-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: #2196f3;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8em;
        }

        .comparison-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin: 40px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table th {
            background: #f8f9fa;
            font-weight: bold;
            color: #495057;
        }

        .rating {
            display: flex;
            align-items: center;
        }

        .star {
            color: #ffd700;
            margin-right: 2px;
        }

        /* Colores por t√©cnica */
        .sprites { --accent-color: #e74c3c; --difficulty-color: #28a745; }
        .tilemap { --accent-color: #3498db; --difficulty-color: #28a745; }
        .line-renderer { --accent-color: #9b59b6; --difficulty-color: #ffc107; }
        .mesh { --accent-color: #f39c12; --difficulty-color: #dc3545; }
        .procedural { --accent-color: #1abc9c; --difficulty-color: #dc3545; }
        .physics { --accent-color: #34495e; --difficulty-color: #ffc107; }

        .advanced-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin: 40px 0;
        }

        .snowball-example {
            background: rgba(255,255,255,0.1);
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .tip-box {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            color: #856404;
        }

        .tip-box::before {
            content: 'üí° ';
            font-size: 1.2em;
        }

        .interactive-demo {
            background: #f1f3f4;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            position: relative;
        }

        .demo-controls {
            margin-bottom: 15px;
        }

        .demo-button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .demo-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèîÔ∏è Terrenos con Pendientes en Unity 2D</h1>
            <p>Gu√≠a completa para crear monta√±as, colinas y terrenos irregulares</p>
            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-top: 20px;">
                <p>‚õ∑Ô∏è Desde sprites simples hasta sistemas procedurales avanzados como Snowball</p>
            </div>
        </div>

        <!-- T√âCNICAS PRINCIPALES -->
        <div class="techniques-grid">
            <!-- SPRITES MODULARES -->
            <div class="technique-card sprites">
                <div class="card-header">
                    <div class="card-icon">üß©</div>
                    <div class="card-title">Sprites Modulares</div>
                    <div class="difficulty">F√°cil</div>
                </div>

                <p>Usa sprites predise√±ados que se combinan para formar pendientes y monta√±as. Ideal para comenzar.</p>

                <div class="visual-example">
                    <h5>Concepto Visual</h5>
                    <div style="display: flex; justify-content: center; align-items: end; height: 100px; background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 40%, transparent 40%);">
                        <div style="width: 60px; height: 20px; background: #8B4513; margin: 2px;"></div>
                        <div style="width: 60px; height: 40px; background: #8B4513; margin: 2px;"></div>
                        <div style="width: 60px; height: 60px; background: #8B4513; margin: 2px;"></div>
                        <div style="width: 60px; height: 40px; background: #8B4513; margin: 2px;"></div>
                        <div style="width: 60px; height: 20px; background: #8B4513; margin: 2px;"></div>
                    </div>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">Sprites de diferentes alturas combinados</p>
                </div>

                <div class="implementation-steps">
                    <h4>üîß Implementaci√≥n</h4>
                    <ol class="step-list">
                        <li>Crear sprites de terreno de diferentes alturas</li>
                        <li>A√±adir PolygonCollider2D a cada sprite</li>
                        <li>Posicionar sprites secuencialmente</li>
                        <li>Ajustar colliders manualmente si es necesario</li>
                    </ol>
                </div>

                <div class="code-snippet">
// Script para colocar sprites de terreno autom√°ticamente
public class TerrainBuilder : MonoBehaviour {
    [Header("Terrain Sprites")]
    public GameObject[] terrainPieces; // Sprites de diferentes alturas
    public float pieceWidth = 2f;
    
    [Header("Height Pattern")]
    public float[] heightPattern = {1f, 2f, 3f, 2f, 1f}; // Patr√≥n de alturas
    
    void Start() {
        BuildTerrain();
    }
    
    void BuildTerrain() {
        for (int i = 0; i < heightPattern.Length; i++) {
            // Seleccionar sprite seg√∫n altura
            int spriteIndex = Mathf.Clamp((int)(heightPattern[i] - 1), 0, terrainPieces.Length - 1);
            GameObject piece = terrainPieces[spriteIndex];
            
            // Posicionar
            Vector3 position = new Vector3(i * pieceWidth, 0f, 0f);
            GameObject terrainPiece = Instantiate(piece, position, Quaternion.identity, transform);
            
            // Configurar collider
            PolygonCollider2D collider = terrainPiece.GetComponent<PolygonCollider2D>();
            if (collider == null) {
                collider = terrainPiece.AddComponent<PolygonCollider2D>();
            }
        }
    }
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h5>Ventajas</h5>
                        <ul>
                            <li>Muy f√°cil de implementar</li>
                            <li>Control art√≠stico total</li>
                            <li>Rendimiento excelente</li>
                            <li>Colliders autom√°ticos</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h5>Desventajas</h5>
                        <ul>
                            <li>Limitado a sprites existentes</li>
                            <li>Puede verse repetitivo</li>
                            <li>Trabajo manual intensivo</li>
                            <li>Menos flexibilidad</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- TILEMAP SYSTEM -->
            <div class="technique-card tilemap">
                <div class="card-header">
                    <div class="card-icon">üó∫Ô∏è</div>
                    <div class="card-title">Tilemap System</div>
                    <div class="difficulty">F√°cil</div>
                </div>

                <p>Utiliza el sistema Tilemap de Unity con tiles especiales para crear terrenos irregulares de forma eficiente.</p>

                <div class="visual-example">
                    <h5>Grid de Tiles</h5>
                    <div style="display: grid; grid-template-columns: repeat(8, 30px); grid-template-rows: repeat(4, 30px); gap: 1px; justify-content: center; margin: 20px 0;">
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #87CEEB;"></div>
                        <div style="background: #87CEEB;"></div>
                        
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                        <div style="background: #8B4513;"></div>
                    </div>
                    <p style="font-size: 0.9em; color: #666;">Tiles dispuestos en grid formando monta√±as</p>
                </div>

                <div class="implementation-steps">
                    <h4>üîß Implementaci√≥n</h4>
                    <ol class="step-list">
                        <li>Crear GameObject con Grid y Tilemap Renderer</li>
                        <li>A√±adir TilemapCollider2D</li>
                        <li>Crear Tile Assets desde sprites</li>
                        <li>Usar Tile Palette para pintar terreno</li>
                        <li>Configurar CompositeCollider2D para optimizar</li>
                    </ol>
                </div>

                <div class="code-snippet">
// Script para generar tilemap procedural
public class TilemapTerrainGenerator : MonoBehaviour {
    [Header("Tilemap Components")]
    public Tilemap tilemap;
    public TileBase grassTile;
    public TileBase dirtTile;
    public TileBase stoneTile;
    
    [Header("Generation Settings")]
    public int mapWidth = 100;
    public int mapHeight = 50;
    public AnimationCurve heightCurve; // Curva que define la forma del terreno
    
    void Start() {
        GenerateTerrain();
    }
    
    void GenerateTerrain() {
        for (int x = 0; x < mapWidth; x++) {
            // Evaluar altura usando la curva
            float normalizedX = (float)x / mapWidth;
            float heightValue = heightCurve.Evaluate(normalizedX);
            int terrainHeight = Mathf.RoundToInt(heightValue * mapHeight);
            
            // Llenar columna de tiles
            for (int y = 0; y <= terrainHeight; y++) {
                Vector3Int position = new Vector3Int(x, y, 0);
                
                // Seleccionar tile seg√∫n altura
                TileBase tileToPlace;
                if (y == terrainHeight) {
                    tileToPlace = grassTile; // Superficie
                } else if (y > terrainHeight - 3) {
                    tileToPlace = dirtTile; // Subcapa
                } else {
                    tileToPlace = stoneTile; // Fondo rocoso
                }
                
                tilemap.SetTile(position, tileToPlace);
            }
        }
        
        // Actualizar colliders
        tilemap.GetComponent<TilemapCollider2D>().enabled = false;
        tilemap.GetComponent<TilemapCollider2D>().enabled = true;
    }
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h5>Ventajas</h5>
                        <ul>
                            <li>Sistema nativo de Unity</li>
                            <li>Muy eficiente para niveles grandes</li>
                            <li>Colliders autom√°ticos optimizados</li>
                            <li>F√°cil edici√≥n con Tile Palette</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h5>Desventajas</h5>
                        <ul>
                            <li>Limitado a grid rectangular</li>
                            <li>Menos suave que otras t√©cnicas</li>
                            <li>Requiere tiles bien dise√±ados</li>
                            <li>Puede verse "pixelado"</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- LINE RENDERER -->
            <div class="technique-card line-renderer">
                <div class="card-header">
                    <div class="card-icon">üìè</div>
                    <div class="card-title">Line Renderer + EdgeCollider</div>
                    <div class="difficulty">Medio</div>
                </div>

                <p>Crea terrenos suaves usando LineRenderer para el visual y EdgeCollider2D para la f√≠sica. Perfecto para curvas org√°nicas.</p>

                <div class="visual-example">
                    <h5>L√≠nea Suave del Terreno</h5>
                    <canvas id="lineCanvas" width="400" height="150" style="border: 1px solid #ccc; border-radius: 5px; background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 50%, #228B22 50%);"></canvas>
                    <p style="font-size: 0.9em; color: #666; margin-top: 10px;">Curva suave conectando puntos de altura</p>
                </div>

                <div class="implementation-steps">
                    <h4>üîß Implementaci√≥n</h4>
                    <ol class="step-list">
                        <li>Crear GameObject con LineRenderer</li>
                        <li>Definir puntos de altura del terreno</li>
                        <li>Generar puntos interpolados entre alturas</li>
                        <li>Crear EdgeCollider2D con los mismos puntos</li>
                        <li>Configurar material y grosor de l√≠nea</li>
                    </ol>
                </div>

                <div class="code-snippet">
public class SmoothTerrainGenerator : MonoBehaviour {
    [Header("Terrain Points")]
    public Vector2[] controlPoints = new Vector2[] {
        new Vector2(0, 0), new Vector2(5, 2), new Vector2(10, 4), 
        new Vector2(15, 3), new Vector2(20, 1)
    };
    
    [Header("Components")]
    public LineRenderer lineRenderer;
    public EdgeCollider2D edgeCollider;
    
    [Header("Settings")]
    public int resolution = 50; // Puntos entre cada control point
    public float terrainWidth = 2f;
    
    void Start() {
        GenerateSmoothTerrain();
    }
    
    void GenerateSmoothTerrain() {
        List<Vector3> terrainPoints = new List<Vector3>();
        List<Vector2> colliderPoints = new List<Vector2>();
        
        // Interpolar entre puntos de control
        for (int i = 0; i < controlPoints.Length - 1; i++) {
            Vector2 startPoint = controlPoints[i];
            Vector2 endPoint = controlPoints[i + 1];
            
            // Generar puntos interpolados
            for (int j = 0; j < resolution; j++) {
                float t = (float)j / resolution;
                
                // Interpolaci√≥n suave (puede usar Bezier para m√°s control)
                Vector2 interpolatedPoint = Vector2.Lerp(startPoint, endPoint, t);
                
                // A√±adir variaci√≥n usando Perlin noise para naturalidad
                float noise = Mathf.PerlinNoise(interpolatedPoint.x * 0.1f, 0) * 0.5f;
                interpolatedPoint.y += noise;
                
                terrainPoints.Add(new Vector3(interpolatedPoint.x, interpolatedPoint.y, 0));
                colliderPoints.Add(interpolatedPoint);
            }
        }
        
        // Configurar LineRenderer
        lineRenderer.positionCount = terrainPoints.Count;
        lineRenderer.SetPositions(terrainPoints.ToArray());
        lineRenderer.startWidth = terrainWidth;
        lineRenderer.endWidth = terrainWidth;
        
        // Configurar EdgeCollider
        edgeCollider.points = colliderPoints.ToArray();
    }
    
    // M√©todo para a√±adir relleno debajo del terreno
    void CreateTerrainFill() {
        // Crear mesh para rellenar bajo la l√≠nea del terreno
        MeshFilter meshFilter = GetComponent<MeshFilter>();
        if (meshFilter == null) meshFilter = gameObject.AddComponent<MeshFilter>();
        
        MeshRenderer meshRenderer = GetComponent<MeshRenderer>();
        if (meshRenderer == null) meshRenderer = gameObject.AddComponent<MeshRenderer>();
        
        // Generar mesh del relleno...
    }
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h5>Ventajas</h5>
                        <ul>
                            <li>Curvas muy suaves y naturales</li>
                            <li>F√°cil de modificar puntos</li>
                            <li>Colliders precisos autom√°ticos</li>
                            <li>Perfecto para terrenos org√°nicos</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h5>Desventajas</h5>
                        <ul>
                            <li>Solo contorno, necesita relleno</li>
                            <li>M√°s complejo que sprites</li>
                            <li>Puede necesitar optimizaci√≥n</li>
                            <li>Requiere ajuste manual de puntos</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- MESH GENERATION -->
            <div class="technique-card mesh">
                <div class="card-header">
                    <div class="card-icon">üî∫</div>
                    <div class="card-title">Generaci√≥n de Mesh</div>
                    <div class="difficulty">Dif√≠cil</div>
                </div>

                <p>Genera meshes din√°micamente para crear terrenos completamente personalizados con texturas y colliders precisos.</p>

                <div class="visual-example">
                    <h5>Mesh Triangulado</h5>
                    <div style="position: relative; height: 120px; background: linear-gradient(45deg, #87CEEB 25%, transparent 25%), linear-gradient(-45deg, #87CEEB 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #228B22 75%), linear-gradient(-45deg, transparent 75%, #228B22 75%); background-size: 20px 20px; background-position: 0 0, 0 10px, 10px -10px, -10px 0px;">
                        <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 60%; background: rgba(139, 69, 19, 0.8); clip-path: polygon(0% 100%, 20% 80%, 40% 60%, 60% 70%, 80% 50%, 100% 60%, 100% 100%);"></div>
                    </div>
                    <p style="font-size: 0.9em; color: #666; margin-top: 10px;">Mesh personalizado con triangulaci√≥n</p>
                </div>

                <div class="implementation-steps">
                    <h4>üîß Implementaci√≥n</h4>
                    <ol class="step-list">
                        <li>Definir v√©rtices del terreno</li>
                        <li>Calcular triangulaci√≥n (Delaunay o simple)</li>
                        <li>Generar UVs para texturas</li>
                        <li>Crear MeshCollider para f√≠sica</li>
                        <li>Aplicar materiales y texturas</li>
                    </ol>
                </div>

                <div class="code-snippet">
public class TerrainMeshGenerator : MonoBehaviour {
    [Header("Terrain Settings")]
    public Vector2[] terrainPoints;
    public float terrainDepth = 10f;
    public Material terrainMaterial;
    
    [Header("Generation")]
    public bool generateOnStart = true;
    
    private Mesh terrainMesh;
    private MeshFilter meshFilter;
    private MeshRenderer meshRenderer;
    private MeshCollider meshCollider;
    
    void Start() {
        InitializeComponents();
        if (generateOnStart) {
            GenerateTerrainMesh();
        }
    }
    
    void InitializeComponents() {
        meshFilter = GetComponent<MeshFilter>();
        if (meshFilter == null) meshFilter = gameObject.AddComponent<MeshFilter>();
        
        meshRenderer = GetComponent<MeshRenderer>();
        if (meshRenderer == null) meshRenderer = gameObject.AddComponent<MeshRenderer>();
        
        meshCollider = GetComponent<MeshCollider>();
        if (meshCollider == null) meshCollider = gameObject.AddComponent<MeshCollider>();
        
        if (terrainMaterial != null) {
            meshRenderer.material = terrainMaterial;
        }
    }
    
    public void GenerateTerrainMesh() {
        if (terrainPoints == null || terrainPoints.Length < 3) {
            Debug.LogError("Need at least 3 terrain points!");
            return;
        }
        
        terrainMesh = new Mesh();
        terrainMesh.name = "Generated Terrain";
        
        // Crear v√©rtices (superficie + base)
        List<Vector3> vertices = new List<Vector3>();
        List<Vector2> uvs = new List<Vector2>();
        List<int> triangles = new List<int>();
        
        // Agregar puntos de la superficie
        float minX = float.MaxValue;
        float maxX = float.MinValue;
        float minY = float.MaxValue;
        
        foreach (Vector2 point in terrainPoints) {
            vertices.Add(new Vector3(point.x, point.y, 0));
            minX = Mathf.Min(minX, point.x);
            maxX = Mathf.Max(maxX, point.x);
            minY = Mathf.Min(minY, point.y);
        }
        
        // Agregar puntos de la base para crear volumen
        vertices.Add(new Vector3(minX, minY - terrainDepth, 0)); // Esquina inferior izquierda
        vertices.Add(new Vector3(maxX, minY - terrainDepth, 0)); // Esquina inferior derecha
        
        // Generar UVs
        for (int i = 0; i < vertices.Count; i++) {
            Vector3 vertex = vertices[i];
            float u = Mathf.InverseLerp(minX, maxX, vertex.x);
            float v = Mathf.InverseLerp(minY - terrainDepth, terrainPoints.Max(p => p.y), vertex.y);
            uvs.Add(new Vector2(u, v));
        }
        
        // Generar tri√°ngulos (triangulaci√≥n simple)
        CreateTriangulation(vertices, triangles);
        
        // Asignar al mesh
        terrainMesh.vertices = vertices.ToArray();
        terrainMesh.uv = uvs.ToArray();
        terrainMesh.triangles = triangles.ToArray();
        terrainMesh.RecalculateNormals();
        terrainMesh.RecalculateBounds();
        
        // Aplicar a componentes
        meshFilter.mesh = terrainMesh;
        meshCollider.sharedMesh = terrainMesh;
    }
    
    void CreateTriangulation(List<Vector3> vertices, List<int> triangles) {
        int surfacePointCount = terrainPoints.Length;
        
        // Triangular la superficie
        for (int i = 0; i < surfacePointCount - 1; i++) {
            // Tri√°ngulo superior de la superficie
            triangles.Add(i);
            triangles.Add(i + 1);
            triangles.Add(surfacePointCount); // Punto base izquierdo
            
            // Tri√°ngulo inferior conectando con base
            triangles.Add(i + 1);
            triangles.Add(surfacePointCount + 1); // Punto base derecho
            triangles.Add(surfacePointCount); // Punto base izquierdo
        }
        
        // Conectar √∫ltimo punto de superficie con base
        triangles.Add(surfacePointCount - 1);
        triangles.Add(surfacePointCount + 1);
        triangles.Add(surfacePointCount);
    }
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h5>Ventajas</h5>
                        <ul>
                            <li>Control total sobre geometr√≠a</li>
                            <li>Texturizado preciso con UVs</li>
                            <li>Colliders perfectamente ajustados</li>
                            <li>Muy eficiente en runtime</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h5>Desventajas</h5>
                        <ul>
                            <li>Muy complejo de implementar</li>
                            <li>Requiere conocimiento de meshes</li>
                            <li>Debugging dif√≠cil</li>
                            <li>Triangulaci√≥n puede ser complicada</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- GENERACI√ìN PROCEDURAL -->
            <div class="technique-card procedural">
                <div class="card-header">
                    <div class="card-icon">üé≤</div>
                    <div class="card-title">Generaci√≥n Procedural</div>
                    <div class="difficulty">Dif√≠cil</div>
                </div>

                <p>Crea terrenos infinitos usando algoritmos como Perlin Noise, simulando sistemas como en Snowball y otros juegos endless.</p>

                <div class="visual-example">
                    <h5>Terreno con Perlin Noise</h5>
                    <canvas id="noiseCanvas" width="400" height="150" style="border: 1px solid #ccc; border-radius: 5px;"></canvas>
                    <div class="demo-controls">
                        <button class="demo-button" onclick="regenerateNoise()" style="--accent-color: #1abc9c;">üîÑ Regenerar</button>
                        <button class="demo-button" onclick="changeScale()" style="--accent-color: #1abc9c;">üìè Cambiar Escala</button>
                    </div>
                </div>

                <div class="implementation-steps">
                    <h4>üîß Implementaci√≥n</h4>
                    <ol class="step-list">
                        <li>Configurar par√°metros de Perlin Noise</li>
                        <li>Generar chunks de terreno din√°micamente</li>
                        <li>Crear sistema de pooling para optimizaci√≥n</li>
                        <li>Implementar streaming para terrenos infinitos</li>
                        <li>A√±adir variaciones y biomas</li>
                    </ol>
                </div>

                <div class="code-snippet">
public class ProceduralTerrainGenerator : MonoBehaviour {
    [Header("Noise Settings")]
    public float noiseScale = 0.1f;
    public float heightMultiplier = 10f;
    public float baseHeight = 0f;
    public AnimationCurve heightCurve;
    
    [Header("Generation Settings")]
    public int chunkSize = 50;
    public float segmentWidth = 1f;
    public int chunksToKeep = 5;
    
    [Header("Prefabs")]
    public GameObject terrainChunkPrefab;
    
    private Queue<TerrainChunk> terrainChunks = new Queue<TerrainChunk>();
    private float lastGeneratedX = 0f;
    private Transform player;
    
    void Start() {
        player = GameObject.FindGameObjectWithTag("Player").transform;
        
        // Generar chunks iniciales
        for (int i = 0; i < chunksToKeep; i++) {
            GenerateTerrainChunk(i * chunkSize * segmentWidth);
        }
    }
    
    void Update() {
        // Generar nuevo chunk cuando el jugador se acerca
        if (player.position.x > lastGeneratedX - (chunksToKeep * chunkSize * segmentWidth)) {
            GenerateTerrainChunk(lastGeneratedX);
            
            // Eliminar chunks antiguos
            if (terrainChunks.Count > chunksToKeep) {
                TerrainChunk oldChunk = terrainChunks.Dequeue();
                Destroy(oldChunk.gameObject);
            }
        }
    }
    
    void GenerateTerrainChunk(float startX) {
        GameObject chunkObject = Instantiate(terrainChunkPrefab, transform);
        TerrainChunk chunk = chunkObject.GetComponent<TerrainChunk>();
        
        List<Vector2> points = new List<Vector2>();
        
        // Generar puntos del terreno usando Perlin Noise
        for (int i = 0; i <= chunkSize; i++) {
            float x = startX + (i * segmentWidth);
            float noiseValue = Mathf.PerlinNoise(x * noiseScale, 0f);
            
            // Aplicar curva de altura para m√°s control
            float height = heightCurve.Evaluate(noiseValue) * heightMultiplier + baseHeight;
            
            points.Add(new Vector2(x, height));
        }
        
        // Configurar el chunk
        chunk.Initialize(points.ToArray());
        terrainChunks.Enqueue(chunk);
        
        lastGeneratedX += chunkSize * segmentWidth;
    }
}

[System.Serializable]
public class TerrainChunk : MonoBehaviour {
    private LineRenderer lineRenderer;
    private EdgeCollider2D edgeCollider;
    private MeshFilter meshFilter;
    private MeshRenderer meshRenderer;
    
    public void Initialize(Vector2[] terrainPoints) {
        SetupComponents();
        GenerateVisuals(terrainPoints);
        GenerateCollider(terrainPoints);
    }
    
    void SetupComponents() {
        lineRenderer = GetComponent<LineRenderer>();
        if (lineRenderer == null) lineRenderer = gameObject.AddComponent<LineRenderer>();
        
        edgeCollider = GetComponent<EdgeCollider2D>();
        if (edgeCollider == null) edgeCollider = gameObject.AddComponent<EdgeCollider2D>();
        
        meshFilter = GetComponent<MeshFilter>();
        meshRenderer = GetComponent<MeshRenderer>();
    }
    
    void GenerateVisuals(Vector2[] points) {
        // Configurar LineRenderer
        lineRenderer.positionCount = points.Length;
        Vector3[] positions = new Vector3[points.Length];
        
        for (int i = 0; i < points.Length; i++) {
            positions[i] = new Vector3(points[i].x, points[i].y, 0);
        }
        
        lineRenderer.SetPositions(positions);
        lineRenderer.startWidth = 0.5f;
        lineRenderer.endWidth = 0.5f;
        
        // Generar mesh de relleno si hay MeshFilter
        if (meshFilter != null) {
            GenerateTerrainMesh(points);
        }
    }
    
    void GenerateCollider(Vector2[] points) {
        edgeCollider.points = points;
    }
    
    void GenerateTerrainMesh(Vector2[] surfacePoints) {
        Mesh mesh = new Mesh();
        
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();
        List<Vector2> uvs = new List<Vector2>();
        
        float minY = surfacePoints.Min(p => p.y) - 20f; // Base del terreno
        
        // A√±adir v√©rtices de superficie
        foreach (Vector2 point in surfacePoints) {
            vertices.Add(new Vector3(point.x, point.y, 0));
        }
        
        // A√±adir v√©rtices de base
        foreach (Vector2 point in surfacePoints) {
            vertices.Add(new Vector3(point.x, minY, 0));
        }
        
        // Generar tri√°ngulos
        for (int i = 0; i < surfacePoints.Length - 1; i++) {
            int topLeft = i;
            int topRight = i + 1;
            int bottomLeft = i + surfacePoints.Length;
            int bottomRight = i + 1 + surfacePoints.Length;
            
            // Tri√°ngulo superior
            triangles.Add(topLeft);
            triangles.Add(topRight);
            triangles.Add(bottomLeft);
            
            // Tri√°ngulo inferior
            triangles.Add(topRight);
            triangles.Add(bottomRight);
            triangles.Add(bottomLeft);
        }
        
        // Generar UVs
        float minX = surfacePoints.Min(p => p.x);
        float maxX = surfacePoints.Max(p => p.x);
        float maxY = surfacePoints.Max(p => p.y);
        
        for (int i = 0; i < vertices.Count; i++) {
            Vector3 vertex = vertices[i];
            float u = Mathf.InverseLerp(minX, maxX, vertex.x);
            float v = Mathf.InverseLerp(minY, maxY, vertex.y);
            uvs.Add(new Vector2(u, v));
        }
        
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.uv = uvs.ToArray();
        mesh.RecalculateNormals();
        
        meshFilter.mesh = mesh;
    }
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h5>Ventajas</h5>
                        <ul>
                            <li>Terrenos infinitos y √∫nicos</li>
                            <li>Muy rejugable</li>
                            <li>Adaptable a diferentes biomas</li>
                            <li>Perfecto para endless runners</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h5>Desventajas</h5>
                        <ul>
                            <li>Complejidad muy alta</li>
                            <li>Dif√≠cil de debuggear</li>
                            <li>Requiere optimizaci√≥n cuidadosa</li>
                            <li>Puede generar terrenos inviables</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- PHYSICS BASADO -->
            <div class="technique-card physics">
                <div class="card-header">
                    <div class="card-icon">‚ö°</div>
                    <div class="card-title">Physics-Based Terrain</div>
                    <div class="difficulty">Medio</div>
                </div>

                <p>Usa elementos de f√≠sica como DistanceJoint2D y HingeJoint2D para crear terrenos deformables y din√°micos.</p>

                <div class="visual-example">
                    <h5>Terreno con F√≠sica</h5>
                    <div style="display: flex; justify-content: center; align-items: end; height: 100px; position: relative;">
                        <div style="width: 20px; height: 60px; background: #8B4513; margin: 1px; border-radius: 50% 50% 0 0; position: relative;">
                            <div style="position: absolute; top: 10px; left: 8px; width: 4px; height: 4px; background: #FFD700; border-radius: 50%;"></div>
                        </div>
                        <div style="width: 20px; height: 80px; background: #8B4513; margin: 1px; border-radius: 50% 50% 0 0; position: relative;">
                            <div style="position: absolute; top: 15px; left: 8px; width: 4px; height: 4px; background: #FFD700; border-radius: 50%;"></div>
                        </div>
                        <div style="width: 20px; height: 70px; background: #8B4513; margin: 1px; border-radius: 50% 50% 0 0; position: relative;">
                            <div style="position: absolute; top: 12px; left: 8px; width: 4px; height: 4px; background: #FFD700; border-radius: 50%;"></div>
                        </div>
                        <div style="width: 20px; height: 50px; background: #8B4513; margin: 1px; border-radius: 50% 50% 0 0; position: relative;">
                            <div style="position: absolute; top: 8px; left: 8px; width: 4px; height: 4px; background: #FFD700; border-radius: 50%;"></div>
                        </div>
                    </div>
                    <p style="font-size: 0.9em; color: #666; margin-top: 10px;">Elementos conectados con joints f√≠sicos</p>
                </div>

                <div class="implementation-steps">
                    <h4>üîß Implementaci√≥n</h4>
                    <ol class="step-list">
                        <li>Crear segmentos de terreno individuales</li>
                        <li>A√±adir Rigidbody2D a cada segmento</li>
                        <li>Conectar con DistanceJoint2D o HingeJoint2D</li>
                        <li>Configurar restricciones de movimiento</li>
                        <li>A√±adir efectos visuales para deformaci√≥n</li>
                    </ol>
                </div>

                <div class="code-snippet">
public class PhysicsTerrainGenerator : MonoBehaviour {
    [Header("Terrain Settings")]
    public GameObject terrainSegmentPrefab;
    public int segmentCount = 20;
    public float segmentSpacing = 1f;
    
    [Header("Physics Settings")]
    public float segmentMass = 1f;
    public float jointDistance = 1.2f;
    public bool canBreak = false;
    public float breakForce = 1000f;
    
    private List<GameObject> terrainSegments = new List<GameObject>();
    
    void Start() {
        GeneratePhysicsTerrain();
    }
    
    void GeneratePhysicsTerrain() {
        GameObject previousSegment = null;
        
        for (int i = 0; i < segmentCount; i++) {
            // Crear segmento
            Vector3 position = new Vector3(i * segmentSpacing, GetHeightForSegment(i), 0);
            GameObject segment = Instantiate(terrainSegmentPrefab, position, Quaternion.identity, transform);
            
            // Configurar f√≠sica
            Rigidbody2D rb = segment.GetComponent<Rigidbody2D>();
            if (rb == null) rb = segment.AddComponent<Rigidbody2D>();
            
            rb.mass = segmentMass;
            rb.freezeRotation = true; // Evitar rotaci√≥n no deseada
            
            // Conectar con segmento anterior
            if (previousSegment != null) {
                ConnectSegments(previousSegment, segment);
            } else {
                // Anclar el primer segmento
                AnchorSegment(segment);
            }
            
            terrainSegments.Add(segment);
            previousSegment = segment;
        }
        
        // Anclar el √∫ltimo segmento tambi√©n
        if (terrainSegments.Count > 0) {
            AnchorSegment(terrainSegments[terrainSegments.Count - 1]);
        }
    }
    
    float GetHeightForSegment(int index) {
        // Funci√≥n que define la forma del terreno
        float normalizedIndex = (float)index / segmentCount;
        return Mathf.Sin(normalizedIndex * Mathf.PI * 2) * 3f; // Forma ondulada
    }
    
    void ConnectSegments(GameObject segmentA, GameObject segmentB) {
        DistanceJoint2D joint = segmentA.AddComponent<DistanceJoint2D>();
        
        joint.connectedBody = segmentB.GetComponent<Rigidbody2D>();
        joint.distance = jointDistance;
        joint.maxDistanceOnly = true;
        
        // Configurar punto de anclaje
        joint.anchor = Vector2.right * 0.5f; // Lado derecho del segmento
        joint.connectedAnchor = Vector2.left * 0.5f; // Lado izquierdo del siguiente
        
        if (canBreak) {
            joint.breakForce = breakForce;
        }
    }
    
    void AnchorSegment(GameObject segment) {
        // Crear ancla invisible para fijar el segmento
        GameObject anchor = new GameObject("Anchor");
        anchor.transform.position = segment.transform.position;
        anchor.transform.SetParent(transform);
        
        Rigidbody2D anchorRb = anchor.AddComponent<Rigidbody2D>();
        anchorRb.bodyType = RigidbodyType2D.Static;
        
        FixedJoint2D fixedJoint = segment.AddComponent<FixedJoint2D>();
        fixedJoint.connectedBody = anchorRb;
    }
    
    // M√©todo para aplicar fuerzas al terreno (explosiones, impactos, etc.)
    public void ApplyForceToTerrain(Vector2 position, float force, float radius) {
        foreach (GameObject segment in terrainSegments) {
            float distance = Vector2.Distance(segment.transform.position, position);
            
            if (distance <= radius) {
                Rigidbody2D rb = segment.GetComponent<Rigidbody2D>();
                Vector2 direction = (segment.transform.position - (Vector3)position).normalized;
                
                // Aplicar fuerza inversamente proporcional a la distancia
                float appliedForce = force * (1f - (distance / radius));
                rb.AddForce(direction * appliedForce, ForceMode2D.Impulse);
            }
        }
    }
    
    // M√©todo para deformar terreno din√°micamente
    public void DeformTerrain(Vector2 position, float deformationRadius, float intensity) {
        foreach (GameObject segment in terrainSegments) {
            float distance = Vector2.Distance(segment.transform.position, position);
            
            if (distance <= deformationRadius) {
                // Mover segmento seg√∫n intensidad y distancia
                float deformationAmount = intensity * (1f - (distance / deformationRadius));
                Vector3 currentPos = segment.transform.position;
                currentPos.y += deformationAmount;
                segment.transform.position = currentPos;
            }
        }
    }
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h5>Ventajas</h5>
                        <ul>
                            <li>Terrenos din√°micos y deformables</li>
                            <li>Interacciones f√≠sicas realistas</li>
                            <li>Efectos de explosiones/impactos</li>
                            <li>Emergent gameplay interesante</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h5>Desventajas</h5>
                        <ul>
                            <li>Puede ser inestable f√≠sicamente</li>
                            <li>Rendimiento variable</li>
                            <li>Dif√≠cil de controlar precisamente</li>
                            <li>Requiere tuning cuidadoso</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- SECCI√ìN DE COMPARACI√ìN -->
        <div class="comparison-section">
            <h2 style="text-align: center; color: #2c3e50; margin-bottom: 30px;">üìä Comparaci√≥n de T√©cnicas</h2>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>T√©cnica</th>
                        <th>Facilidad de Uso</th>
                        <th>Rendimiento</th>
                        <th>Flexibilidad</th>
                        <th>Resultado Visual</th>
                        <th>Mejor Para</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Sprites Modulares</strong></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ</div></td>
                        <td>Principiantes, prototipos r√°pidos</td>
                    </tr>
                    <tr>
                        <td><strong>Tilemap System</strong></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ</div></td>
                        <td>Niveles grandes, estilo pixel art</td>
                    </tr>
                    <tr>
                        <td><strong>Line Renderer</strong></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td>Terrenos org√°nicos, curvas suaves</td>
                    </tr>
                    <tr>
                        <td><strong>Generaci√≥n de Mesh</strong></td>
                        <td><div class="rating">‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td>Control total, optimizaci√≥n m√°xima</td>
                    </tr>
                    <tr>
                        <td><strong>Generaci√≥n Procedural</strong></td>
                        <td><div class="rating">‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ</div></td>
                        <td>Endless runners, mundos infinitos</td>
                    </tr>
                    <tr>
                        <td><strong>Physics-Based</strong></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></td>
                        <td><div class="rating">‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ</div></td>
                        <td>Terrenos destructibles, simulaci√≥n</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- AN√ÅLISIS ESPEC√çFICO DE SNOWBALL -->
        <div class="advanced-section">
            <h2 style="text-align: center; margin-bottom: 30px;">‚õ∑Ô∏è An√°lisis: C√≥mo Snowball Implementa Terrenos</h2>
            
            <div class="snowball-example">
                <h3>üéø T√©cnicas Utilizadas en Snowball</h3>
                <p style="margin-bottom: 20px;">Los juegos tipo Snowball combinan m√∫ltiples t√©cnicas para lograr terrenos suaves y din√°micos:</p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;">
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                        <h4>üåä 1. Generaci√≥n Procedural</h4>
                        <ul style="margin-top: 15px;">
                            <li>Perlin Noise para altura base</li>
                            <li>M√∫ltiples octavas para detalle</li>
                            <li>Chunks din√°micos adelante del jugador</li>
                            <li>Eliminaci√≥n de chunks antiguos</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                        <h4>üìè 2. Line Renderer + Edge Collider</h4>
                        <ul style="margin-top: 15px;">
                            <li>Curvas B√©zier para suavidad</li>
                            <li>Edge Collider para f√≠sica precisa</li>
                            <li>Interpolaci√≥n entre puntos</li>
                            <li>Grosor variable del terreno</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                        <h4>üî∫ 3. Mesh Din√°mico</h4>
                        <ul style="margin-top: 15px;">
                            <li>Relleno debajo de la l√≠nea</li>
                            <li>UVs para texturas de nieve</li>
                            <li>Triangulaci√≥n optimizada</li>
                            <li>Deformaci√≥n por impactos</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px;">
                        <h4>‚ö° 4. Efectos Especiales</h4>
                        <ul style="margin-top: 15px;">
                            <li>Part√≠culas de nieve volando</li>
                            <li>Huellas del snowball</li>
                            <li>Deformaci√≥n temporal</li>
                            <li>Parallax en el fondo</li>
                        </ul>
                    </div>
                </div>
                
                <div class="code-snippet" style="margin-top: 30px;">
// Implementaci√≥n simplificada estilo Snowball
public class SnowballTerrainGenerator : MonoBehaviour {
    [Header("Snowball Terrain Settings")]
    public float noiseScale = 0.02f;
    public float amplitude = 8f;
    public float baseHeight = 0f;
    public int pointsPerChunk = 30;
    public float chunkWidth = 20f;
    
    [Header("Visual Settings")]
    public Material snowMaterial;
    public LineRenderer terrainLine