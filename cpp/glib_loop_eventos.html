<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLib Event Loop: Explicado con Android</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #000;
        }
        
        .intro {
            background: #f5f5f5;
            border: 2px solid #000;
            padding: 25px;
            margin-bottom: 40px;
        }
        
        .intro h2 {
            margin-bottom: 15px;
        }
        
        .architecture {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 40px 0;
        }
        
        .component {
            border: 2px solid #000;
            padding: 25px;
            background: #ffffff;
            position: relative;
        }
        
        .component h2 {
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        .subtitle {
            font-style: italic;
            color: #333;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .component ul {
            list-style: none;
            padding-left: 0;
        }
        
        .component li {
            padding: 8px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .component li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 0;
        }
        
        .android-box {
            background: #f9f9f9;
            border-left: 4px solid #000;
            padding: 15px;
            margin: 15px 0;
        }
        
        .android-box strong {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .connection {
            text-align: center;
            font-size: 2em;
            margin: -15px 0;
            color: #000;
        }
        
        /* ESTILOS MEJORADOS PARA C√ìDIGO */
        .code-block {
            font-family: 'Courier New', Consolas, Monaco, monospace;
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-left: 3px solid #000;
            overflow-x: auto;
            white-space: pre-wrap;       /* Permite saltos de l√≠nea */
            word-wrap: break-word;       /* Rompe palabras largas */
            line-height: 1.5;
            font-size: 0.9em;
        }
        
        /* Alternativa con <pre><code> */
        pre {
            margin: 0;
            font-family: 'Courier New', Consolas, Monaco, monospace;
            white-space: pre-wrap;
        }
        
        code {
            font-family: 'Courier New', Consolas, Monaco, monospace;
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        pre code {
            padding: 0;
            background: transparent;
        }
        
        .side-by-side {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .side-by-side > div {
            border: 1px solid #000;
            padding: 15px;
        }
        
        .side-by-side h3 {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ccc;
        }
        
        .highlight {
            background: #e8e8e8;
            padding: 10px;
            margin: 10px 0;
            border-left: 3px solid #000;
        }
        
        .mapping {
            background: #fafafa;
            border: 2px solid #000;
            padding: 20px;
            margin: 30px 0;
        }
        
        .mapping h2 {
            margin-bottom: 20px;
        }
        
        .mapping-item {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 15px;
            align-items: center;
            margin: 15px 0;
            padding: 15px;
            background: white;
            border: 1px solid #ddd;
        }
        
        .mapping-item .arrow {
            font-size: 1.5em;
            font-weight: bold;
        }
        
        table {
            width: 100%;
            margin-top: 10px;
            border-collapse: collapse;
        }
        
        th, td {
            text-align: left;
            padding: 8px;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            border-bottom: 2px solid #000;
        }
        
        @media (max-width: 768px) {
            .side-by-side {
                grid-template-columns: 1fr;
            }
            
            .mapping-item {
                grid-template-columns: 1fr;
                text-align: center;
            }
            
            .mapping-item .arrow {
                display: none;
            }
        }
    </style>
</head>
<body>
    <h1>üîÑ GLib Event Loop Explicado con Android</h1>
    
    <div class="intro">
        <h2>üéØ La Gran Analog√≠a</h2>
        <p style="margin-bottom: 15px;">
            Si has trabajado con <strong>Handler, Looper y Message</strong> en Android, 
            ya entiendes el 90% de GLib. Son pr√°cticamente lo mismo, solo que GLib es m√°s antiguo 
            y m√°s gen√©rico (no solo para UI).
        </p>
        <div class="highlight">
            <strong>En Android:</strong> Looper + Handler + Message/Runnable<br>
            <strong>En GLib:</strong> GMainContext + GMainLoop + GSource
        </div>
    </div>
    
    <div class="mapping">
        <h2>üìã Mapeo Directo Android ‚Üî GLib</h2>
        
        <div class="mapping-item">
            <div>
                <strong>Android: Looper</strong><br>
                El loop infinito que procesa mensajes de una cola
            </div>
            <div class="arrow">‚ü∫</div>
            <div>
                <strong>GLib: GMainContext</strong><br>
                El motor que procesa eventos de m√∫ltiples fuentes
            </div>
        </div>
        
        <div class="mapping-item">
            <div>
                <strong>Android: Handler</strong><br>
                La interfaz para enviar mensajes al Looper
            </div>
            <div class="arrow">‚ü∫</div>
            <div>
                <strong>GLib: GMainLoop</strong><br>
                La interfaz para controlar el GMainContext
            </div>
        </div>
        
        <div class="mapping-item">
            <div>
                <strong>Android: Message / Runnable</strong><br>
                El trabajo a ejecutar en el loop
            </div>
            <div class="arrow">‚ü∫</div>
            <div>
                <strong>GLib: GSource</strong><br>
                La fuente de eventos (timeout, I/O, custom)
            </div>
        </div>
    </div>
    
    <div class="architecture">
        <!-- GMainLoop -->
        <div class="component">
            <h2>1Ô∏è‚É£ GMainLoop = Handler (simplificado)</h2>
            <p class="subtitle">Control b√°sico: start, stop, query</p>
            
            <div class="side-by-side">
                <div>
                    <h3>Android Handler</h3>
                    <pre class="code-block"><code>Handler handler = new Handler(Looper.myLooper());

// Enviar trabajo
handler.post(runnable);
handler.postDelayed(runnable, 1000);

// Control
handler.removeCallbacks(runnable);</code></pre>
                </div>
                
                <div>
                    <h3>GLib GMainLoop</h3>
                    <pre class="code-block"><code>GMainLoop *loop = g_main_loop_new(context, FALSE);

// Iniciar (bloquea hasta quit)
g_main_loop_run(loop);

// Detener (desde cualquier callback)
g_main_loop_quit(loop);

// Consultar
gboolean running = g_main_loop_is_running(loop);</code></pre>
                </div>
            </div>
            
            <div class="android-box">
                <strong>ü§î ¬øPor qu√© parece m√°s simple?</strong>
                Porque en Android, Handler hace dos cosas: <em>enviar mensajes</em> Y <em>controlar el loop</em>. 
                En GLib est√°n separados: GMainLoop solo controla (run/quit), 
                y agregas trabajo directamente al GMainContext.
            </div>
        </div>
        
        <div class="connection">‚Üì controla a ‚Üì</div>
        
        <!-- GMainContext -->
        <div class="component">
            <h2>2Ô∏è‚É£ GMainContext = Looper (el motor real)</h2>
            <p class="subtitle">El cerebro que gestiona la cola de eventos</p>
            
            <div class="side-by-side">
                <div>
                    <h3>Android Looper</h3>
                    <pre class="code-block"><code>// Thread principal ya tiene Looper
Looper mainLooper = Looper.getMainLooper();

// En thread secundario:
class MyThread extends Thread {
    public void run() {
        Looper.prepare(); // Crear Looper
        
        // Tu c√≥digo...
        handler = new Handler();
        
        Looper.loop(); // BLOQUEA: procesar mensajes
    }
}

// Detener desde otro lado
mainLooper.quit();</code></pre>
                    
                    <div class="highlight" style="margin-top: 15px;">
                        <strong>Looper.loop() hace:</strong><br>
                        1. Sacar mensaje de MessageQueue<br>
                        2. Despachar a su Handler.target<br>
                        3. Repetir infinitamente
                    </div>
                </div>
                
                <div>
                    <h3>GLib GMainContext</h3>
                    <pre class="code-block"><code>// Thread principal tiene default context
GMainContext *def = g_main_context_default();

// En thread secundario:
void* thread_func(void *data) {
    GMainContext *ctx = g_main_context_new();
    
    // Asociar a ESTE thread
    g_main_context_push_thread_default(ctx);
    
    // Tu c√≥digo: agregar sources...
    g_timeout_add(1000, callback, data);
    
    // BLOQUEA: procesar eventos
    GMainLoop *loop = g_main_loop_new(ctx, FALSE);
    g_main_loop_run(loop);
}</code></pre>
                    
                    <div class="highlight" style="margin-top: 15px;">
                        <strong>Iteraci√≥n de GMainContext:</strong><br>
                        1. Prepare: calcular pr√≥ximo timeout<br>
                        2. Poll: esperar eventos (I/O, timers)<br>
                        3. Check: verificar sources listas<br>
                        4. Dispatch: ejecutar callbacks<br>
                        5. Repetir infinitamente
                    </div>
                </div>
            </div>
            
            <div class="android-box">
                <strong>üí° Diferencia clave:</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>Looper:</strong> Solo procesa mensajes en una cola (MessageQueue)</li>
                    <li><strong>GMainContext:</strong> Procesa m√∫ltiples tipos de eventos: timeouts, file descriptors (sockets, pipes), idle callbacks, custom sources</li>
                </ul>
                <p style="margin-top: 10px;">
                    Es como si Looper solo manejara <code>postDelayed()</code>, pero GMainContext 
                    adem√°s maneja <code>Socket.select()</code>, <code>FileObserver</code>, etc., todo integrado.
                </p>
            </div>
            
            <div class="android-box">
                <strong>üßµ Thread-Local Context:</strong>
                <pre class="code-block"><code>// Android: cada thread tiene su Looper
Looper.prepare();  // Crea Looper para ESTE thread
Looper looper = Looper.myLooper(); // Obtener el del thread actual

// GLib: mismo concepto
g_main_context_push_thread_default(context);
GMainContext *ctx = g_main_context_get_thread_default();</code></pre>
                Cuando llamas <code>g_timeout_add()</code> SIN especificar contexto, 
                usa el "thread default" (como Handler sin especificar Looper usa myLooper()).
            </div>
        </div>
        
        <div class="connection">‚Üì contiene m√∫ltiples ‚Üì</div>
        
        <!-- GSource -->
        <div class="component">
            <h2>3Ô∏è‚É£ GSource = Message + Runnable (m√°s poderoso)</h2>
            <p class="subtitle">Las tareas que el loop ejecutar√°</p>
            
            <div class="side-by-side">
                <div>
                    <h3>Android: Enviar Trabajo al Handler</h3>
                    <pre class="code-block"><code>Handler handler = new Handler();

// ‚è∞ Ejecutar despu√©s de X tiempo
handler.postDelayed(new Runnable() {
    @Override
    public void run() {
        // Tu c√≥digo
        
        // Repetir? Llamar postDelayed otra vez
        handler.postDelayed(this, 1000);
    }
}, 1000);

// ‚è∏ Ejecutar cuando est√© idle
Looper.myQueue().addIdleHandler(() -> {
    // Cuando no haya mensajes
    return true; // true = mantener, false = eliminar
});

// üìÅ I/O as√≠ncrono? Necesitas otras APIs
// (AsyncTask, Executors, etc.)</code></pre>
                </div>
                
                <div>
                    <h3>GLib: Agregar GSource</h3>
                    <pre class="code-block"><code>// ‚è∞ Timeout (como postDelayed)
g_timeout_add(1000, my_callback, user_data);

gboolean my_callback(gpointer data) {
    // Tu c√≥digo
    
    return G_SOURCE_CONTINUE; // true = repetir
    // return G_SOURCE_REMOVE;  // false = eliminar
}

// ‚è∏ Idle (cuando no hay nada m√°s)
g_idle_add(idle_callback, user_data);

// üìÅ I/O as√≠ncrono (INTEGRADO!)
GIOChannel *channel = g_io_channel_unix_new(fd);
g_io_add_watch(channel, G_IO_IN, 
               io_callback, user_data);</code></pre>
                </div>
            </div>
            
            <div class="android-box">
                <strong>üéØ Diferencias importantes:</strong>
                <table>
                    <tr>
                        <th>Caracter√≠stica</th>
                        <th>Android Message/Runnable</th>
                        <th>GLib GSource</th>
                    </tr>
                    <tr>
                        <td><strong>Repetici√≥n autom√°tica</strong></td>
                        <td>NO. Debes llamar postDelayed() otra vez</td>
                        <td>S√ç. Return TRUE para continuar</td>
                    </tr>
                    <tr>
                        <td><strong>I/O integrado</strong></td>
                        <td>NO. Necesitas otras APIs</td>
                        <td>S√ç. GIOChannel nativo</td>
                    </tr>
                    <tr>
                        <td><strong>Prioridad</strong></td>
                        <td>Impl√≠cita (orden en cola)</td>
                        <td>Expl√≠cita (n√∫mero de prioridad)</td>
                    </tr>
                    <tr>
                        <td><strong>Custom sources</strong></td>
                        <td>Limitado (subclase de Message)</td>
                        <td>Total flexibilidad (g_source_new)</td>
                    </tr>
                </table>
            </div>
            
            <div class="android-box">
                <strong>üì¶ Tipos de GSource (paquetes predefinidos):</strong>
                <pre class="code-block"><code>// Como diferentes tipos de mensajes en Android:

g_timeout_add()      ‚Üí Handler.postDelayed()
g_idle_add()         ‚Üí IdleHandler
g_io_add_watch()     ‚Üí Socket.select() integrado al Looper
g_child_watch_add()  ‚Üí Process.waitFor() no bloqueante
g_source_new()       ‚Üí Custom Message con tu l√≥gica</code></pre>
            </div>
        </div>
    </div>
    
    <div class="component" style="margin-top: 40px;">
        <h2>üîÑ Flujo Completo: Tu C√≥digo Traducido a Android</h2>
        
        <div class="side-by-side">
            <div>
                <h3>Tu C√≥digo GLib</h3>
                <pre class="code-block"><code>// Main thread
GMainContext *ctx = g_main_context_new();
GMainLoop *loop = g_main_loop_new(ctx, FALSE);

// Lanzar thread
g_thread_new("worker", thread_func, data);

// Thread secundario
void* thread_func(void *data) {
    // Asociar contexto a este thread
    g_main_context_push_thread_default(ctx);
    
    // Agregar timer (cada 1 segundo)
    g_timeout_add(1000, on_timeout, data);
    
    // INICIAR LOOP (bloquea)
    g_main_loop_run(loop);
    
    // Cleanup
    g_main_context_pop_thread_default(ctx);
}

gboolean on_timeout(gpointer data) {
    counter++;
    if (counter >= 5) {
        g_main_loop_quit(loop); // Detener
        return FALSE; // No repetir m√°s
    }
    return TRUE; // Continuar
}</code></pre>
            </div>
            
            <div>
                <h3>Equivalente Android</h3>
                <pre class="code-block"><code>// Main thread
// (Android UI thread ya tiene su Looper)

// Lanzar thread
new Thread(() -> {
    // Crear Looper para este thread
    Looper.prepare();
    
    // Crear Handler
    Handler handler = new Handler();
    
    // Agregar timer (cada 1 segundo)
    final int[] counter = {0};
    Runnable task = new Runnable() {
        @Override
        public void run() {
            counter[0]++;
            if (counter[0] >= 5) {
                Looper.myLooper().quit(); // Detener
                return; // No repostear
            }
            handler.postDelayed(this, 1000); // Repetir
        }
    };
    handler.postDelayed(task, 1000);
    
    // INICIAR LOOP (bloquea)
    Looper.loop();
    
}).start();</code></pre>
            </div>
        </div>
        
        <div class="highlight" style="margin-top: 20px;">
            <strong>üéØ Observa las similitudes:</strong>
            <ol style="padding-left: 20px; margin-top: 10px;">
                <li>Ambos crean un event loop en un thread secundario</li>
                <li>Ambos asocian el loop al thread actual (<code>prepare()</code> vs <code>push_thread_default()</code>)</li>
                <li>Ambos programan trabajo repetitivo (<code>postDelayed</code> recursivo vs <code>g_timeout_add</code>)</li>
                <li>Ambos bloquean en el loop hasta que se llama quit()</li>
                <li>Ambos permiten detener desde el callback (<code>return FALSE</code> vs no repostear)</li>
            </ol>
        </div>
    </div>
    
    <div class="android-box" style="margin-top: 40px; background: #f0f0f0;">
        <strong>üí° Resumen Final:</strong>
        <p style="margin-top: 15px; font-size: 1.1em;">
            Si entiendes <code>Looper.prepare() ‚Üí Handler.post() ‚Üí Looper.loop()</code> en Android,
            ya entiendes <code>GMainContext ‚Üí GSource ‚Üí g_main_loop_run()</code> en GLib.
        </p>
        <p style="margin-top: 10px; font-size: 1.1em;">
            La √∫nica diferencia real es que GLib puede manejar m√°s tipos de eventos nativamente 
            (especialmente I/O con file descriptors), mientras que Android Looper est√° m√°s enfocado 
            en mensajes simples para UI.
        </p>
    </div>
</body>
</html>