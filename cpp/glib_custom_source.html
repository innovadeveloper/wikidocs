<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom GSource - Creando Tu Propio Tipo de Evento</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            color: #000000;
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #000;
        }
        
        .hero {
            background: #f5f5f5;
            border: 3px solid #000;
            padding: 30px;
            margin-bottom: 40px;
            text-align: center;
        }
        
        .hero h2 {
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        .hero p {
            font-size: 1.2em;
            margin: 10px 0;
        }
        
        .flow-diagram {
            background: #fafafa;
            border: 2px solid #000;
            padding: 30px;
            margin: 30px 0;
        }
        
        .flow-box {
            background: white;
            border: 2px solid #000;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            position: relative;
        }
        
        .flow-box h3 {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ddd;
        }
        
        .flow-arrow {
            text-align: center;
            font-size: 2em;
            margin: 10px 0;
            color: #000;
        }
        
        .highlight-box {
            background: #e8e8e8;
            border-left: 4px solid #000;
            padding: 15px;
            margin: 15px 0;
        }
        
        .code-block {
            font-family: 'Courier New', Consolas, Monaco, monospace;
            background: #f5f5f5;
            padding: 15px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-left: 3px solid #000;
            overflow-x: auto;
            white-space: pre-wrap;
            line-height: 1.5;
            font-size: 0.9em;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison > div {
            border: 2px solid #000;
            padding: 20px;
        }
        
        .comparison h3 {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ccc;
        }
        
        .step {
            background: white;
            border: 2px solid #000;
            padding: 20px;
            margin: 20px 0;
        }
        
        .step-number {
            display: inline-block;
            background: #000;
            color: #fff;
            width: 35px;
            height: 35px;
            line-height: 35px;
            text-align: center;
            border-radius: 50%;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .step h3 {
            display: inline;
            font-size: 1.3em;
        }
        
        .lifecycle {
            background: #f9f9f9;
            border: 2px solid #000;
            padding: 25px;
            margin: 30px 0;
        }
        
        .lifecycle-phase {
            background: white;
            border: 1px solid #000;
            padding: 15px;
            margin: 15px 0;
        }
        
        .lifecycle-phase h4 {
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        .android-analogy {
            background: #e0f7fa;
            border: 2px solid #000;
            padding: 20px;
            margin: 20px 0;
        }
        
        .android-analogy h3 {
            margin-bottom: 15px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background: #f0f0f0;
            border-bottom: 2px solid #000;
            font-weight: bold;
        }
        
        .key-concept {
            background: #fff9c4;
            border: 2px solid #000;
            padding: 20px;
            margin: 20px 0;
        }
        
        .key-concept h3 {
            margin-bottom: 10px;
        }
        
        @media (max-width: 768px) {
            .comparison {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>üõ†Ô∏è Custom GSource: Creando Tu Propio Tipo de Evento</h1>
    
    <div class="hero">
        <h2>¬øQu√© estamos haciendo?</h2>
        <p><strong>Creando un tipo personalizado de evento (Custom GSource)</strong></p>
        <p>En lugar de usar <code>g_timeout_add()</code> o <code>g_idle_add()</code> predefinidos,</p>
        <p>estamos construyendo nuestro propio mecanismo de eventos desde cero.</p>
    </div>
    
    <div class="android-analogy">
        <h3>ü§ñ Analog√≠a con Android</h3>
        <p style="margin-bottom: 15px;">
            En Android, cuando usas <code>Handler.postDelayed()</code>, est√°s usando un tipo predefinido de mensaje.
            Crear un Custom GSource es como crear tu propia subclase de <code>Message</code> con l√≥gica personalizada
            de cu√°ndo debe ejecutarse.
        </p>
        <pre class="code-block"><code>// Android: Usar mensaje predefinido
handler.postDelayed(runnable, 1000);

// Android equivalente: Custom Message con l√≥gica propia
class CustomMessage extends Message {
    @Override
    boolean isReady() { /* tu l√≥gica */ }
    @Override
    void execute() { /* tu c√≥digo */ }
}</code></pre>
    </div>
    
    <div class="flow-diagram">
        <h2 style="text-align: center; margin-bottom: 30px;">üìä Arquitectura del Custom GSource</h2>
        
        <div class="flow-box">
            <h3>üèóÔ∏è CustomSource (tu estructura)</h3>
            <pre class="code-block"><code>typedef struct {
    GSource source;         // ‚Üê DEBE ser el primer campo (herencia en C)
    gint interval_ms;       // Tu dato: intervalo personalizado
    gint64 last_time;       // Tu dato: timestamp del √∫ltimo evento
    gint counter;           // Tu dato: contador de eventos
    gpointer user_data;     // Datos del usuario
    GSourceFunc callback;   // Callback del usuario
} CustomSource;</code></pre>
            <div class="highlight-box">
                <strong>üí° Key Point:</strong> Est√°s extendiendo GSource agregando tus propios campos.
                Es como hacer "herencia" en C (el primer campo DEBE ser GSource).
            </div>
        </div>
        
        <div class="flow-arrow">‚Üì</div>
        
        <div class="flow-box">
            <h3>‚öôÔ∏è GSourceFuncs (el contrato)</h3>
            <p style="margin-bottom: 15px;">
                Le dices a GLib c√≥mo manejar tu Custom GSource implementando estas 3 funciones:
            </p>
            <pre class="code-block"><code>static GSourceFuncs custom_funcs = {
    .prepare  = custom_source_prepare,   // ¬øCu√°ndo estar√° listo?
    .check    = custom_source_check,     // ¬øYa est√° listo?
    .dispatch = custom_source_dispatch,  // ¬°Ejecutar ahora!
    .finalize = NULL                     // Cleanup (opcional)
};</code></pre>
        </div>
        
        <div class="flow-arrow">‚Üì</div>
        
        <div class="flow-box">
            <h3>üîÑ GMainContext usa tus funciones</h3>
            <p>En cada iteraci√≥n del event loop, GMainContext llama autom√°ticamente:</p>
            <ol style="padding-left: 30px; margin-top: 10px;">
                <li><code>prepare()</code> ‚Üí Pregunta si el evento est√° listo</li>
                <li><code>poll()</code> ‚Üí GLib duerme el tiempo necesario</li>
                <li><code>check()</code> ‚Üí Confirma si realmente est√° listo</li>
                <li><code>dispatch()</code> ‚Üí Ejecuta tu l√≥gica + callback del usuario</li>
            </ol>
        </div>
    </div>
    
    <div class="lifecycle">
        <h2 style="margin-bottom: 20px;">üîÑ Ciclo de Vida: Las 3 Fases Cr√≠ticas</h2>
        
        <div class="lifecycle-phase">
            <h4><span class="step-number">1</span> prepare() - "¬øEst√°s listo?"</h4>
            <pre class="code-block"><code>static gboolean custom_source_prepare(GSource *source, gint *timeout_) {
    CustomSource *cs = (CustomSource *)source;
    gint64 now = g_get_monotonic_time();
    gint64 elapsed_ms = (now - cs->last_time) / 1000;

    if (elapsed_ms >= cs->interval_ms) {
        *timeout_ = 0;      // ¬°Ya est√° listo!
        return TRUE;        // Dispatch inmediatamente
    } else {
        *timeout_ = cs->interval_ms - elapsed_ms;  // Dormir X ms
        return FALSE;       // No listo a√∫n
    }
}</code></pre>
            <div class="highlight-box">
                <strong>üéØ Prop√≥sito:</strong> Calcular cu√°nto tiempo debe dormir GMainContext antes de volver a revisar.
                <br><strong>Return:</strong> TRUE = listo para dispatch, FALSE = necesita m√°s tiempo
                <br><strong>timeout_:</strong> Cu√°ntos ms esperar (0 = inmediato, -1 = indefinido)
            </div>
        </div>
        
        <div class="lifecycle-phase">
            <h4><span class="step-number">2</span> check() - "¬øConfirmas que est√°s listo?"</h4>
            <pre class="code-block"><code>static gboolean custom_source_check(GSource *source) {
    CustomSource *cs = (CustomSource *)source;
    gint64 now = g_get_monotonic_time();
    gint64 elapsed_ms = (now - cs->last_time) / 1000;
    
    return elapsed_ms >= cs->interval_ms;  // TRUE = ejecutar ahora
}</code></pre>
            <div class="highlight-box">
                <strong>üéØ Prop√≥sito:</strong> Despu√©s del poll(), confirmar si realmente debemos ejecutar.
                <br><strong>Return:</strong> TRUE = llamar a dispatch(), FALSE = omitir esta vez
                <br><strong>Nota:</strong> Similar a prepare(), pero despu√©s de que poll() retorna.
            </div>
        </div>
        
        <div class="lifecycle-phase">
            <h4><span class="step-number">3</span> dispatch() - "¬°Ejecuta tu l√≥gica!"</h4>
            <pre class="code-block"><code>static gboolean custom_source_dispatch(
    GSource *source,
    GSourceFunc callback,    // ‚Üê Callback del USUARIO
    gpointer user_data       // ‚Üê Datos del USUARIO
) {
    CustomSource *cs = (CustomSource *)source;
    cs->last_time = g_get_monotonic_time();  // Actualizar timestamp
    cs->counter++;                           // Incrementar contador
    
    g_print("[CustomSource] Evento #%d\n", cs->counter);
    
    if (callback)
        return callback(user_data); // ejecuta el callback del usuario
    if (cs->callback)
        return cs->callback(cs->user_data); // ejecuta el callback del desarrollador (definido en la estructura)
    return TRUE;  // TRUE = mantener, FALSE = eliminar source
}</code></pre>
            <div class="highlight-box">
                <strong>üéØ Prop√≥sito:</strong> Ejecutar tu l√≥gica interna + llamar al callback del usuario.
                <br><strong>callback:</strong> La funci√≥n que el usuario pas√≥ (on_custom_event)
                <br><strong>Return:</strong> Lo que retorne el callback del usuario (TRUE = continuar, FALSE = eliminar)
            </div>
        </div>
    </div>
    
    <div class="key-concept">
        <h3>üîë Concepto Clave: Dos Capas de Callbacks</h3>
        <table>
            <tr>
                <th>Capa</th>
                <th>Qui√©n la define</th>
                <th>Prop√≥sito</th>
            </tr>
            <tr>
                <td><strong>1. Funciones del GSourceFuncs</strong></td>
                <td>T√∫ (el creador del Custom GSource)</td>
                <td>L√≥gica interna: cu√°ndo ejecutar, c√≥mo calcular tiempo, etc.</td>
            </tr>
            <tr>
                <td><strong>2. Callback del usuario final</strong></td>
                <td>El usuario de tu Custom GSource</td>
                <td>La acci√≥n real que el usuario quiere ejecutar cuando ocurra el evento</td>
            </tr>
        </table>
        
        <pre class="code-block" style="margin-top: 15px;"><code>// TU C√ìDIGO (crear el Custom GSource):
static gboolean custom_source_dispatch(..., GSourceFunc callback, ...) {
    // Tu l√≥gica interna aqu√≠
    cs->counter++;
    
    // Llamar al callback del USUARIO
    if (callback)
        return callback(user_data);  // ‚Üê Esto ejecuta on_custom_event()
    
    return TRUE;
}

// C√ìDIGO DEL USUARIO (usar tu Custom GSource):
gboolean on_custom_event(gpointer user_data) {
    g_print("[Callback] Evento personalizado recibido\n");
    return TRUE;  // ‚Üê Este retorno lo recibe dispatch() arriba
}</code></pre>
    </div>
    
    <div class="step">
        <h3><span class="step-number">4</span> Crear y Registrar el Custom GSource</h3>
        <pre class="code-block"><code>GSource *custom_source_new(gint interval_ms, 
                           GSourceFunc callback, 
                           gpointer user_data) {
    
    // 1Ô∏è‚É£ Crear el GSource con tus funciones personalizadas
    CustomSource *cs = (CustomSource *)g_source_new(
        &custom_funcs,           // Tus 3 funciones
        sizeof(CustomSource)     // Tama√±o de tu estructura
    );
    
    // 2Ô∏è‚É£ Inicializar TUS campos personalizados
    cs->interval_ms = interval_ms;
    cs->last_time = g_get_monotonic_time();
    cs->callback = callback;    // callback del desarrollador
    cs->user_data = user_data;
    cs->counter = 0;
    
    return (GSource *)cs;
}</code></pre>
    </div>
    
    <div class="step">
        <h3><span class="step-number">5</span> Usar el Custom GSource</h3>
        <pre class="code-block"><code>// En el thread secundario:
void *event_thread_func(void *arg) {
    ThreadData *data = (ThreadData *)arg;
    
    // Asociar contexto al thread
    g_main_context_push_thread_default(data->context);
    
    // üî∏ Crear tu Custom GSource (intervalo: 2000ms)
    GSource *source = custom_source_new(2000, on_custom_event, NULL);   // seteando el callback de desarrollador
    g_source_set_callback(source, on_custom_event, NULL, NULL); // seteando el callback de usuario

    // üî∏ Adjuntar al contexto
    g_source_attach(source, data->context);
    g_source_unref(source);  // GMainContext ahora lo posee
    
    // Iniciar el loop
    g_main_loop_run(data->loop);
    
    g_main_context_pop_thread_default(data->context);
    return NULL;
}</code></pre>
        <div class="highlight-box" style="margin-top: 15px;">
            <strong>üìå Nota:</strong> Se necesita llamar <code>g_source_set_callback()</code> porque
            el callback q se pas√≥ por <code>custom_source_new()</code> es un tipo de callback interno del 
            desarrollador. Sin embargo el otro tipo de callback de usuario se setea a trav√©s de <code>g_source_set_callback()</code> 
            y ese es el glib envia a trav√©s de su funci√≥n de despacho
        </div>
    </div>
    
    <div class="comparison">
        <div>
            <h3>‚ùå Sin Custom GSource (limitado)</h3>
            <pre class="code-block"><code>// Solo puedes usar tipos predefinidos:

// ‚è∞ Timeout fijo
g_timeout_add(1000, callback, data);

// ‚è∏ Idle (sin control de timing)
g_idle_add(callback, data);

// üìÅ I/O simple
g_io_add_watch(channel, G_IO_IN, 
               callback, data);

// ‚ùå No puedes:
// - L√≥gica personalizada de timing
// - Combinar m√∫ltiples condiciones
// - Mantener estado interno complejo</code></pre>
        </div>
        
        <div>
            <h3>‚úÖ Con Custom GSource (poderoso)</h3>
            <pre class="code-block"><code>// Puedes crear CUALQUIER l√≥gica:

// ‚úÖ Timing personalizado
// ‚úÖ Mantener estado interno
// ‚úÖ Combinar m√∫ltiples condiciones
// ‚úÖ L√≥gica compleja de cu√°ndo ejecutar

// Ejemplos de Custom GSource:
// - Evento cada X tiempo PERO solo en horario laboral
// - Evento cuando sensor + temperatura > umbral
// - Evento cuando m√∫ltiples sockets tengan datos
// - Evento con backoff exponencial
// - Evento basado en machine learning
// - ¬°Lo que tu imaginaci√≥n requiera!</code></pre>
        </div>
    </div>
    
    <div class="flow-diagram">
        <h2 style="text-align: center; margin-bottom: 30px;">üîÑ Flujo Completo de Ejecuci√≥n</h2>
        
        <div class="flow-box" style="background: #e3f2fd;">
            <strong>Iteraci√≥n 1 (t=0ms):</strong>
            <ol style="padding-left: 30px; margin-top: 10px;">
                <li><code>prepare()</code> ‚Üí elapsed=0ms, interval=2000ms ‚Üí return FALSE, timeout=2000</li>
                <li>GMainContext duerme 2000ms</li>
                <li>Nadie ejecuta nada todav√≠a</li>
            </ol>
        </div>
        
        <div class="flow-arrow">‚Üì (2000ms despu√©s)</div>
        
        <div class="flow-box" style="background: #fff3e0;">
            <strong>Iteraci√≥n 2 (t=2000ms):</strong>
            <ol style="padding-left: 30px; margin-top: 10px;">
                <li><code>prepare()</code> ‚Üí elapsed=2000ms, interval=2000ms ‚Üí return TRUE, timeout=0</li>
                <li><code>check()</code> ‚Üí elapsed=2000ms ‚Üí return TRUE</li>
                <li><code>dispatch()</code> ‚Üí Imprime "[CustomSource] Evento #1"</li>
                <li>Llama <code>on_custom_event()</code> ‚Üí Imprime "[Callback] Evento personalizado recibido"</li>
                <li><code>on_custom_event()</code> retorna TRUE ‚Üí mantener el source activo</li>
            </ol>
        </div>
        
        <div class="flow-arrow">‚Üì (2000ms despu√©s)</div>
        
        <div class="flow-box" style="background: #e3f2fd;">
            <strong>Iteraci√≥n 3 (t=4000ms):</strong>
            <ol style="padding-left: 30px; margin-top: 10px;">
                <li>Se repite el mismo proceso</li>
                <li>Imprime "[CustomSource] Evento #2"</li>
                <li>Imprime "[Callback] Evento personalizado recibido"</li>
            </ol>
        </div>
        
        <div class="flow-arrow">‚Üì (contin√∫a...)</div>
        
        <div class="flow-box" style="background: #ffebee;">
            <strong>Despu√©s de 12 segundos (main thread):</strong>
            <ol style="padding-left: 30px; margin-top: 10px;">
                <li><code>sleep(12)</code> termina en el main thread</li>
                <li><code>g_main_loop_quit(loop)</code> detiene el event loop</li>
                <li><code>g_main_loop_run()</code> retorna en el thread secundario</li>
                <li>Cleanup y finalizaci√≥n</li>
            </ol>
        </div>
    </div>
    
    <div class="android-analogy" style="margin-top: 40px;">
        <h3>ü§ñ Equivalente en Android (conceptual)</h3>
        <pre class="code-block"><code>// Tu Custom GSource es como crear un custom Message:

class CustomMessage extends Message {
    long intervalMs;
    long lastTime;
    int counter;
    
    // prepare() equivalente
    boolean isReady() {
        long elapsed = System.currentTimeMillis() - lastTime;
        return elapsed >= intervalMs;
    }
    
    // dispatch() equivalente
    void execute() {
        lastTime = System.currentTimeMillis();
        counter++;
        Log.d("CustomMessage", "Evento #" + counter);
        
        // Llamar callback del usuario
        if (callback != null) {
            callback.run();
        }
    }
}

// Usar tu Custom Message:
Handler handler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
        if (msg instanceof CustomMessage) {
            CustomMessage cm = (CustomMessage) msg;
            if (cm.isReady()) {
                cm.execute();
                // Reenviar si debe continuar
                sendMessageDelayed(cm, cm.intervalMs);
            }
        }
    }
};

// Crear y enviar
CustomMessage msg = new CustomMessage();
msg.intervalMs = 2000;
msg.callback = () -> Log.d("User", "¬°Evento recibido!");
handler.sendMessage(msg);</code></pre>
        <div class="highlight-box" style="margin-top: 15px;">
            <strong>üí° Diferencia clave:</strong> En GLib, el GMainContext ya tiene toda la infraestructura
            para manejar sources personalizados. Solo defines las 3 funciones (prepare/check/dispatch) 
            y GLib se encarga del resto. En Android tendr√≠as que implementar m√°s l√≥gica manualmente.
        </div>
    </div>
    
    <div class="key-concept" style="margin-top: 40px; background: #f0f0f0;">
        <h3>üéØ Resumen: ¬øCu√°ndo crear un Custom GSource?</h3>
        <table style="margin-top: 15px;">
            <tr>
                <th>Escenario</th>
                <th>¬øCustom GSource?</th>
                <th>Alternativa</th>
            </tr>
            <tr>
                <td>Evento cada X segundos</td>
                <td>‚ùå NO</td>
                <td>Usa <code>g_timeout_add()</code></td>
            </tr>
            <tr>
                <td>Evento cuando hay datos en socket</td>
                <td>‚ùå NO</td>
                <td>Usa <code>g_io_add_watch()</code></td>
            </tr>
            <tr>
                <td>Evento con l√≥gica compleja de timing</td>
                <td>‚úÖ S√ç</td>
                <td>Custom GSource te da control total</td>
            </tr>
            <tr>
                <td>Evento basado en m√∫ltiples condiciones</td>
                <td>‚úÖ S√ç</td>
                <td>Puedes verificar todo en check()</td>
            </tr>
            <tr>
                <td>Evento con estado interno complejo</td>
                <td>‚úÖ S√ç</td>
                <td>Tu estructura puede tener cualquier campo</td>
            </tr>
            <tr>
                <td>Integrar con biblioteca externa</td>
                <td>‚úÖ S√ç</td>
                <td>Wrapper para eventos de otras APIs</td>
            </tr>
        </table>
        
        <p style="margin-top: 20px; font-size: 1.1em;">
            <strong>Regla de oro:</strong> Si los tipos predefinidos (<code>g_timeout_add</code>, <code>g_idle_add</code>, <code>g_io_add_watch</code>)
            no cubren tu caso de uso, entonces necesitas un Custom GSource.
        </p>
    </div>
</body>
</html>